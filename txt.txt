//server

import socket

# Create socket
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = '127.0.0.1'
port = 12345

# Bind socket to address and port
server_socket.bind((host, port))

# Listen for connections
server_socket.listen(1)
print(f"Server listening on {host}:{port}")
print("Waiting for client connection...")

# Accept connection
client_socket, address = server_socket.accept()
print(f"Connection from {address} established")

# Receive data from client
data = client_socket.recv(1024).decode()
print(f"Received data: {data}")

# Send response if needed
# client_socket.send("Response message".encode())

# Close connections
client_socket.close()
server_socket.close()

//client
import socket

# Create socket
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = '127.0.0.1'
port = 12345

# Connect to server
print(f"Connecting to server at {host}:{port}")
client_socket.connect((host, port))

# Send data to server
message = "Your message here"
client_socket.send(message.encode())
print("Message sent to server")

# Receive response if needed
# response = client_socket.recv(1024).decode()
# print(f"Received response: {response}")

# Close connection
client_socket.close()

____________________________________________________________________________
//caesar and multiple chat

import socket 
 
def encrypt(msg,key): 
    encrypted="" 
    j=0 
    for i in range(0,len(msg)): 
        if j>3: 
            j=0 
        k=int(key[j]) 
        val=ord(msg[i]) 
        if msg[i].isupper(): 
            val=(((ord(msg[i])-65)+k)%26)+65                           //-k for decryption
        elif msg[i].islower(): 
            val=(((ord(msg[i])-97)+k)%26)+97 
        encrypted+=chr(val) 
        j+=1 
    return encrypted 
 
while True: 
    clientSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 
    addr=('127.0.0.1', 12000) 
    msg=input("Enter Message: ") 
    key=input("Enter Key: ") 
    encrypted=encrypt(msg,key) 
    print(encrypted) 
    clientSocket.sendto(encrypted.encode(), addr) 
    if msg=="exit": 
        break
____________________________________________________________________________
//playfair
import socket 
 
def decrypt(msg,table): 
    decrypted="" 
    for i in range(0,len(msg),2): 
        sub=msg[i:i+2] 
 
        row1=-1 
        col1=-1 
        row2=-1 
        col2=-1 
 
        for j in range(0,5): 
            for k in range(0,5): 
                if(table[j][k]==sub[0]): 
                    row1=j 
                    col1=k  
                    break 
            if(row1!=-1 and col1!=-1): 
                break  
         
        for j in range(0,5): 
            for k in range(0,5): 
                if(table[j][k]==sub[1]): 
                    row2=j 
                    col2=k  
                    break 
            if(row2!=-1 and col2!=-1): 
                break  
        if(col1==col2): 
            decrypted+=table[(row1-1)%5][col1]+table[(row2-1)%5][col2] 
        elif(row1==row2): 
            decrypted+=table[row1][(col1-1)%5]+table[row2][(col2-1)%5] 
        else: 
            decrypted+=table[row1][col2]+table[row2][col1] 
    return decrypted 
 
def gettable(msg): 
    unq=[];l=[];temp=[];k=0 
    for i in msg: 
        if i not in unq: 
            unq.append(i) 
    for i in range(5): 
        t=[] 
        for j in range(5): 
            t.append(' ') 
        l.append(t) 
    for i in unq: 
        temp.append(i) 
    for j in range(97,123): 
        c=chr(j) 
        if c not in temp: 
            temp.append(c) 
    for i in range(0,5): 
        for j in range(0,5): 
            if(temp[k]=='j'): 
                k+=1 
            l[i][j]=temp[k] 
            k+=1 
    for i in range(5): 
        for j in range(5): 
            print(l[i][j],end=" ") 
        print() 
    return l 
 
 
while True: 
    serverSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 
    serverSocket.bind(('', 12000)) 
    cipher, addr = serverSocket.recvfrom(1024) 
    key=input("Enter Key: ") 
    table=gettable(key) 
    print(decrypt(cipher.decode(),table)) 
    if(decrypt(cipher.decode(),table)=="exit"): 
        break  
 
 
//client.py ( Client ) 
 
import socket 
 
def encrypt(msg,table): 
    encrypted="" 
    for i in range(0,len(msg),2): 
        sub=msg[i:i+2] 
 
        row1=-1 
        col1=-1 
        row2=-1 
        col2=-1 
 
        for j in range(0,5): 
            for k in range(0,5): 
                if(table[j][k]==sub[0]): 
                    row1=j 
                    col1=k  
                    break 
            if(row1!=-1 and col1!=-1): 
                break  
         
        for j in range(0,5): 
            for k in range(0,5): 
                if(table[j][k]==sub[1]): 
                    row2=j 
                    col2=k  
                    break 
            if(row2!=-1 and col2!=-1): 
                break  
        if(col1==col2): 
            encrypted+=table[(row1+1)%5][col1]+table[(row2+1)%5][col2] 
        elif(row1==row2): 
            encrypted+=table[row1][(col1+1)%5]+table[row2][(col2+1)%5] 
        else: 
            encrypted+=table[row1][col2]+table[row2][col1] 
    print(encrypted) 
    return encrypted 
 
def gettable(msg): 
    unq=[];l=[];temp=[];k=0 
    for i in msg: 
        if i not in unq: 
            unq.append(i) 
    for i in range(5): 
        t=[] 
        for j in range(5): 
            t.append(' ') 
        l.append(t) 
    for i in unq: 
        temp.append(i) 
    for j in range(97,123): 
        c=chr(j) 
        if c not in temp: 
            temp.append(c) 
    for i in range(0,5): 
        for j in range(0,5): 
            if(temp[k]=='j'): 
                k+=1 
            l[i][j]=temp[k] 
            k+=1 
    for i in range(5): 
        for j in range(5): 
            print(l[i][j],end=" ") 
        print() 
    return l 
     
 
def changetext(msg): 
    ans="" 
    for i in range(0,len(msg)-1): 
        if msg[i]==msg[i+1]: 
            ans+=msg[i]+'x' 
        else: 
            ans+=msg[i] 
    ans+=msg[len(msg)-1] 
    if(len(ans)%2!=0): 
        ans+='x' 
    print(ans) 
    return ans 
 
while True: 
    clientSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 
    addr=('127.0.0.1', 12000) 
    msg=input("Enter Message: ") 
    key=input("Enter Key: ") 
    msg=msg.lower() 
    msg=msg.replace(" ","") 
    changed=changetext(msg) 
    table=gettable(key) 
    encrypted=encrypt(changed,table) 
    clientSocket.sendto(encrypted.encode(), addr) 
    if(msg=="exit"): 
        Break
____________________________________________________________________________

//HILL CIPHER 
//server.py( Server )
import socket
import numpy as np
from sympy import mod_inverse

def calinv(keymat):
    A = np.array(keymat)
    det = round(np.linalg.det(A))
    det_mod = det % 26
    try:
        det_inv = mod_inverse(det_mod, 26)
    except ValueError:
        raise ValueError("Determinant has no modular inverse under mod 26.")
    adjugate = np.round(det * np.linalg.inv(A)).astype(int) % 26
    inverse_matrix = (det_inv * adjugate) % 26
    return inverse_matrix.astype(int)

def getencmatrix(msg):
    mat=[]
    for i in range(0,len(msg)):
        mat.append(ord(msg[i])-65)
    return mat

def getmsg(invkeymat,encmat):
    ans=""
    for i in range(0,len(invkeymat)):
        sum=0
        for j in range(0,len(invkeymat)):
            sum+=invkeymat[i][j]*encmat[j]
        ans+=chr(sum%26+65)
    return ans

while True:
    serverSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    serverSocket.bind(('', 12400))
    cipher, addr = serverSocket.recvfrom(1024)
    encrypted=cipher.decode()
    n=int(input())
    print('Enter Key Matrix: ')
    keymat=[]
    for i in range(n):
        l=[]
        for j in range(n):
            x=int(input())
            l.append(x)
        keymat.append(l)
    print(keymat)
    print("Inverse Key Matrix: ")
    invkeymat=calinv(keymat)
    print(np.array(invkeymat).tolist())
    encmat=getencmatrix(encrypted)
    print("Encrypted text Matrix: ")
    print(encmat)
    text=getmsg(invkeymat,encmat)
    print(text)
    if text=="BYE":
        break

//client.py ( Client )
import socket

def getmsgmatrix(msg):
    mat=[]
    for i in range(0,len(msg)):
        mat.append(ord(msg[i])-65)
    print(mat)
    return mat

def encyrpt(keymat,msgmat):
    ans=""
    for i in range(0,len(keymat)):
        sum=0
        for j in range(0,len(keymat)):
            sum+=keymat[i][j]*msgmat[j]
        ans+=chr(sum%26+65)
    return ans

while True:
    clientSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    addr=('127.0.0.1', 12400)
    n=int(input())
    print('Enter Key Matrix: ')
    keymat=[]
    for i in range(n):
        l=[]
        for j in range(n):
            x=int(input())
            l.append(x)
        keymat.append(l)
    print(keymat)
    msg=input("Enter Message: ")
    msgmat=getmsgmatrix(msg)
    encyrpted=encyrpt(keymat,msgmat)
    print(encyrpted)
    clientSocket.sendto(encyrpted.encode(), addr)
    if msg=="BYE":
        break
____________________________________________________________________________
//RAIL FENCE CIPHER
//server.py ( Server ):
import socket

def decodefence(msg,depth):

    n=len(msg)
    l=[]
    for i in range(depth):
        t=[]
        for j in range(n):
            t.append(' ')
        l.append(t)
    ind=0
    i=0
    j=0

    while(True):
        while(i<depth):
            if(ind==len(msg)):
                break
            l[i][j]='.'
            i+=1
            j+=1
            ind+=1
        i-=2
        while(i>=0):
            if(ind==len(msg)):
                break
            l[i][j]='.'
            i-=1
            j+=1
            ind+=1
        i+=2
        if(ind==len(msg)):
            break

    ind=0
    for i in range(depth):
        for j in range(n):
            if(l[i][j]=='.' and ind<len(msg)):
                l[i][j]=msg[ind]
                ind+=1
    for i in range(depth):
        for j in range(n):
            print(l[i][j],end=" ")
        print()

    ans=""
    i=0
    j=0
    ind=0
    while(True):
        while(i<depth):
            if(ind==len(msg)):
                break
            ans+=l[i][j]
            i+=1
            j+=1
            ind+=1
        i-=2
        while(i>=0):
            if(ind==len(msg)):
                break
            ans+=l[i][j]
            i-=1
            j+=1
            ind+=1
        i+=2
        if(ind==len(msg)):
            break   
    return ans

while True:
    serverSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    serverSocket.bind(('', 12400))
    cipher, addr = serverSocket.recvfrom(1024)
    encrypted=cipher.decode()
    depth=int(input("Enter Depth: "))
    print("Cipher Text:",encrypted)
    decrypted=decodefence(encrypted,depth)
    print("Decypted Text:",decrypted)
    if decrypted=="EXIT":
        break


//client.py ( Client )
import socket

def createfence(depth,msg):
    n=len(msg)
    l=[]
    for i in range(depth):
        t=[]
        for j in range(n):
            t.append(' ')
        l.append(t)
    ind=0
    i=0
    j=0
    while(True):
        while(i<depth):
            if(ind>=len(msg)):
                break
            l[i][j]=msg[ind]
            i+=1
            j+=1
            ind+=1
        i-=2
        while(i>=0):
            if(ind>=len(msg)):
                break
            l[i][j]=msg[ind]
            i-=1
            j+=1
            ind+=1
        i+=2
        if(ind>=len(msg)):
            break
    msg=""
    for i in range(depth):
        for j in range(n):
            print(l[i][j],end=" ")
            if(l[i][j]!=" "):
                msg+=l[i][j]
        print()
    return msg




while True:
    clientSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    addr=('127.0.0.1', 12400)
    depth=int(input("Enter Depth: "))
    msg=input("Enter Message: ")
    encrypted=createfence(depth,msg)
    print("Encrypted Text:",encrypted)
    clientSocket.sendto(encrypted.encode(), addr)
    if msg=="EXIT":
        break
____________________________________________________________________________
//COLUMNAR CIPHER:
//Server.py ( Server ):
import socket

def decode(msg,key,n):
    k=1
    ind=0
    l=[]
    for i in range(n):
        t=[]
        for j in range(n):
            t.append(' ')
        l.append(t)
    for i in range(n):
        col=key.index(str(k))
        for j in range(n):
            l[j][col]=msg[ind]
            ind+=1
        k+=1
    print("Matrix: ")
    msg=""
    for i in range(n):
        for j in range(n):
            print(l[i][j],end=' ')
            msg+=l[i][j]
        print()
    return msg

        

while True:
    serverSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    serverSocket.bind(('', 12400))
    cipher, addr = serverSocket.recvfrom(1024)
    encrypted=cipher.decode()
    n=int(input("Enter n: "))
    key=input("Enter Key: ")
    print("Cipher Text:",encrypted)
    decrypted=decode(encrypted,key,n)
    print("Decrypted Text:",decrypted)
    if decrypted=="EXITEXITEXITEXIT":
        break
//client.py ( Client ):
import socket

def makemat(msg,n):
    l=[]
    t=[]
    for i in range(0,len(msg)):
        t.append(msg[i])
        if(len(t)==n):
            l.append(t)
            t=[]
    if(len(t)>0):
        while(len(t)<n):
            t.append(' ')
    l.append(t)
    return l

def encrypt(l,key):
    msg=""
    k=1
    for i in range(n):
        col=-1
        for j in range(n):
            if key[j]==str(k):
                col=j
            if(col!=-1):
                for p in range(n):
                    msg+=l[p][col]
                break
        k+=1
    return msg 

while True:
    clientSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    addr=('127.0.0.1', 12400)
    n=int(input("Enter n: "))
    key=input("Enter Key: ")
    msg=input("Enter Message: ")
    l=makemat(msg,n)
    print("Matrix: ")
    for i in range(n):
        for j in range(n):
            print(l[i][j] ,end=" ")
        print()
    encrypted=encrypt(l,key)
    print(encrypted)
    clientSocket.sendto(encrypted.encode(), addr)
    if msg=="EXITEXITEXITEXIT":
        break
____________________________________________________________________________
//AES encryption
hex_table = [
    [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76],
    [0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0],
    [0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15],
    [0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75],
    [0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84],
    [0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf],
    [0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8],
    [0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2],
    [0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73],
    [0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb],
    [0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79],
    [0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08],
    [0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a],
    [0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e],
    [0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf],
    [0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16],
]

rcon = [0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000]

def rot_word(word):
    return ((word << 8) | (word >> 24)) & 0xFFFFFFFF

def sub_word(word):
    result = 0
    for i in range(4):
        byte = (word >> (24 - 8 * i)) & 0xFF
        row = byte >> 4
        col = byte & 0x0F
        sub_byte = hex_table[row][col]
        result = (result << 8) | sub_byte
    return result
p=[]
yoyo=[]
print("Enter tex:")
for i in range(4):
    while True:
        try:
            key = input(f"Enter text p[{i}]: ")
            p.append(int(key, 16))
            yoyo.append(int(key,16))
            break
        except ValueError:
            print("Invalid hexadecimal input. Please try again.")

w = []
print("Enter key:")
for i in range(4):
    while True:
        try:
            key = input(f"Enter key w[{i}]: ")
            w.append(int(key, 16))
            break
        except ValueError:
            print("Invalid hexadecimal input. Please try again.")

for i in range(4, 44):
    temp = w[i-1]
    if i % 4 == 0:
        temp = sub_word(rot_word(temp)) ^ rcon[i//4 - 1]
    w.append(w[i-4] ^ temp)


def hex_to_matrix(p):
    matrix = []
    for value in p:
        hex_str = f'{value:08x}'
        row = [int(hex_str[i:i+2], 16) for i in range(0, 8, 2)]
        matrix.append(row)
    return matrix

def galois_multiplication(a, b):
    p = 0
    for i in range(8):
        if b & 1:
            p ^= a
        high_bit_set = a & 0x80
        a <<= 1
        if high_bit_set:
            a ^= 0x1b  
        b >>= 1
    return p & 0xff

def matrix_multiply(state_matrix, mix_matrix):
    result = [[0 for _ in range(4)] for _ in range(4)]
    
    for i in range(4):
        for j in range(4):
            sum = 0
            for k in range(4):
                sum ^= galois_multiplication(mix_matrix[i][k], state_matrix[k][j])
            result[i][j] = sum
    
    return result

def matrix_to_array(matrix):
    result = []
    for row in matrix:
        value = (row[0] << 24) | (row[1] << 16) | (row[2] << 8) | row[3]
        result.append(value)
    return result


mix = [
    [0x02, 0x03, 0x01, 0x01],
    [0x01, 0x02, 0x03, 0x01],
    [0x01, 0x01, 0x02, 0x03],
    [0x03, 0x01, 0x01, 0x02]
]

for i in range(4):
    p[i]=p[i]^w[i]
for i in range(4):
    print(f"p[{i}] = 0x{p[i]:08x}")  
for j in range(1,10):
    for i in range(4):
        p[i]=sub_word(p[i])
        if i == 0:
            p[i] = p[i]
        elif i == 1:
            p[i] = rot_word(p[i])
        elif i == 2:
            p[i] = rot_word(rot_word(p[i]))
        elif i == 3:
            p[i] = rot_word(rot_word(rot_word(p[i])))
    result = matrix_multiply(hex_to_matrix(p), mix)
    p=matrix_to_array(result)
    for i in range(4):
        p[i] = p[i]^w[(4*j)+i]
    for i in range(4):
        print(f"p[{i}] = 0x{p[i]:08x}")  
for i in range(4):
    p[i]=sub_word(p[i])
    if i == 0:
        p[i] = p[i]^w[40]
    elif i == 1:
        p[i] = rot_word(p[i])^w[41]
    elif i == 2:
        p[i] = rot_word(rot_word(p[i]))^w[42]
    elif i == 3:
        p[i] = rot_word(rot_word(rot_word(p[i])))^w[43]

print("\nEncrypted text:")
for i in range(4):
    print(f"p[{i}] = 0x{p[i]:08x}")   

# verification
for i in range(4):
    yoyo[i]=sub_word(yoyo[i])
    if i == 0:
        yoyo[i] = yoyo[i]
    elif i == 1:
        yoyo[i] = rot_word(yoyo[i])
    elif i == 2:
        yoyo[i] = rot_word(rot_word(yoyo[i]))
    elif i == 3:
        yoyo[i] = rot_word(rot_word(rot_word(yoyo[i])))

result = matrix_multiply(hex_to_matrix(yoyo), mix)
yoyo=matrix_to_array(result)

print("\nVerification:")
for i in range(4):
    print(f"yoyo[{i}] = 0x{yoyo[i]:08x}") 
____________________________________________________________________________
//RSA
//Server Code
import socket

def imod(e, n):
    g, x, y = extended_gcd(e, n)
    if g != 1:
        return "Error"        
    return x % n

def extended_gcd(a, b):
    if b == 0:
        return a, 1, 0
    else:
        g, x1, y1 = extended_gcd(b, a % b)
        x = y1
        y = x1 - (a // b) * y1
        return g, x, y

def euler(n):
    result = n
    p = 2
    while p * p <= n:
        if n % p == 0:
            while n % p == 0:
                n //= p
            result -= result // p
        p += 1
    if n > 1:
        result -= result // n
    return result

server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = '127.0.0.1'
port = 12345
server_socket.bind((host, port))
server_socket.listen(1)
print(f"Server listening on {host}:{port}")

print("Waiting for client connection...")
client_socket, address = server_socket.accept()
print(f"Connection from {address} established")

p = int(input("Enter p: "))
q = int(input("Enter q: "))
n = p * q
e = int(input("Enter public key (e): "))
T = euler(n)
d = imod(e, T)

encrypted_message = int(client_socket.recv(1024).decode())
print(f"Received encrypted message: {encrypted_message}")

decrypted_message = pow(encrypted_message, d, n)
print(f"Decrypted message: {decrypted_message}")

client_socket.close()
server_socket.close()


//Client Code
import socket

client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = '127.0.0.1'
port = 12345


print(f"Connecting to server at {host}:{port}")
client_socket.connect((host, port))

p = int(input("Enter p: "))
q = int(input("Enter q: "))
n = p * q
e = int(input("Enter public key (e): "))

message = int(input("Enter message : "))
encrypted_message = pow(message, e, n)
print(f"Encrypted message: {encrypted_message}")

client_socket.send(str(encrypted_message).encode())
print("Message sent to server")

client_socket.close()

____________________________________________________________________________
//elgammal
Server Code
import socket

def mod_inverse(a, m):
    def extended_gcd(a, b):
        if b == 0:
            return a, 1, 0
        else:
            g, x1, y1 = extended_gcd(b, a % b)
            x = y1
            y = x1 - (a // b) * y1
            return g, x, y
    
    g, x, _ = extended_gcd(a, m)
    if g != 1:
        raise Exception('Modular inverse does not exist')
    return x % m

server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = '127.0.0.1'
port = 12345
server_socket.bind((host, port))
server_socket.listen(1)
print(f"Server listening on {host}:{port}")

print("Waiting for client connection...")
client_socket, address = server_socket.accept()
print(f"Connection from {address} established")

p = int(input("Enter p: "))
g = int(input("Enter g: "))
x = int(input("Enter private key (x): "))

encrypted_message = client_socket.recv(1024).decode()
c1, c2 = map(int, encrypted_message.split(','))
print(f"Received encrypted message - c1: {c1}, c2: {c2}")

s = pow(c1, x, p)
s_inv = mod_inverse(s, p)
decrypted_message = (c2 * s_inv) % p

print(f"Decrypted message: {decrypted_message}")

client_socket.close()
server_socket.close()


Client Code
import socket

client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = '127.0.0.1'
port = 12345

print(f"Connecting to server at {host}:{port}")
client_socket.connect((host, port))

p = int(input("Enter p: "))  
g = int(input("Enter g: "))  
x = int(input("Enter private key (x): "))
m = int(input("Enter message : "))  

h = pow(g, x, p)
print(f"Public key (h): {h}")

k = 5
c1 = pow(g, k, p)
c2 = (m * pow(h, k, p)) % p  

encrypted_message = f"{c1},{c2}"
print(f"Encrypted message (c1,c2): {encrypted_message}")
client_socket.send(encrypted_message.encode())
print("Message sent to server")

client_socket.close()
____________________________________________________________________________
//diffie-hellman
//Config.py
q = int(input("Enter prime number q: "))
a = int(input("Enter primitive root a: "))

PORT_A = 65432  
PORT_B = 65433  
PORT_C = 65434  

def comp_x(private_key):
    return pow(a, private_key, q)

def comp_y(public_key, private_key):
    return pow(public_key, private_key, q)

def fkey(shared_component, private_key):
    return pow(shared_component, private_key, q)

//pya.py
import socket
import random
import time
from config import q, PORT_A, PORT_B, comp_x, comp_y, fkey

def pya():
    name = "A"
    my_port = PORT_A
    next_port = PORT_B
    next_host = 'localhost'
    
    private_key = random.randint(1, q-1)    
    public_key = comp_x(private_key)
    
    print(f"Party {name} initialized with:")
    print(f"  Private key (X{name.lower()}): {private_key}")
    print(f"  Public key (Y{name.lower()}): {public_key}")
    
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind(('localhost', my_port))
    server_socket.listen(1)
    print(f"Party {name} is listening on port {my_port}")
    
    try:
        print(f"Sending Xa to B")
        send_message(next_host, next_port, public_key)
        
        print(f"Receiving Xc from C")
        received_public_key = receive_message(server_socket)
        
        shared_component = comp_y(received_public_key, private_key)
        print(f"Za: {shared_component}")
        
        print(f"Sending Za to B")
        send_message(next_host, next_port, shared_component)
        
        print(f"Receiving Zc from C")
        received_shared_component = receive_message(server_socket)
        
        final_key = fkey(received_shared_component, private_key)
        print(f"Final shared key: {final_key}")
        
        print(f"{name} completed the key exchange protocol.")
        
    except Exception as e:
        print(f"Error in Party {name}: {e}")
    finally:
        server_socket.close()

def send_message(host, port, message):
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client_socket.connect((host, port))
    client_socket.sendall(str(message).encode())
    print(f"Sent message: {message}")
    client_socket.close()
    return True

def receive_message(server_socket):
    conn, addr = server_socket.accept()
    data = conn.recv(4096).decode()
    message = int(data)
    conn.close()
    print(f"Received message: {message}")
    return message

pya()



//pyb.py
import socket
import random
import time
from config import q, PORT_B, PORT_C, comp_x, comp_y, fkey

def party_b():
    name = "B"
    my_port = PORT_B
    next_port = PORT_C
    next_host = 'localhost'
    
    private_key = random.randint(1, q-1)  
    
    public_key = comp_x(private_key)
    
    print(f"Party {name} initialized with:")
    print(f"  Private key (X{name.lower()}): {private_key}")
    print(f"  Public key (Y{name.lower()}): {public_key}")
    
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind(('localhost', my_port))
    server_socket.listen(1)
    print(f"Party {name} is listening on port {my_port}")
    
    try:
        print(f"Receiving Xa from A")
        received_public_key = receive_message(server_socket)
        
        print(f"Sending Xb to C")
        send_message(next_host, next_port, public_key)
        
        shared_component = comp_y(received_public_key, private_key)
        print(f"Zb: {shared_component}")
        
        print(f"Receiving Za from A")
        received_shared_component = receive_message(server_socket)
        
        print(f"Sending Zb to C")
        send_message(next_host, next_port, shared_component)
        
        final_key = fkey(received_shared_component, private_key)
        print(f"Computed final shared key: {final_key}")
        
        print(f"Party {name} completed the key exchange protocol.")
        
    except Exception as e:
        print(f"Error in Party {name}: {e}")
    finally:
        server_socket.close()

def send_message(host, port, message):
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client_socket.connect((host, port))
    client_socket.sendall(str(message).encode())
    print(f"Sent message: {message}")
    client_socket.close()
    return True

def receive_message(server_socket):
    conn, addr = server_socket.accept()
    data = conn.recv(4096).decode()
    message = int(data)
    conn.close()
    print(f"Received message: {message}")
    return message

party_b()

//pyc.py
import socket
import random
import time
from config import q, PORT_C, PORT_A, comp_x, comp_y, fkey

def party_c():
    name = "C"
    my_port = PORT_C
    next_port = PORT_A
    next_host = 'localhost'
    
    private_key = random.randint(1, q-1)  
    
    public_key = comp_x(private_key)
    
    print(f"Party {name} initialized with:")
    print(f"  Private key (X{name.lower()}): {private_key}")
    print(f"  Public key (Y{name.lower()}): {public_key}")
    
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind(('localhost', my_port))
    server_socket.listen(1)
    print(f"Party {name} is listening on port {my_port}")
    
    try:
        print(f"Receiving Xb from B")
        received_public_key = receive_message(server_socket)
        
        print(f"Sending Xc to A")
        send_message(next_host, next_port, public_key)
        
        shared_component = comp_y(received_public_key, private_key)
        print(f"Zc: {shared_component}")
        
        print(f"Receiving Zb from B")
        received_shared_component = receive_message(server_socket)
        
        print(f"Sending Zc to A")
        send_message(next_host, next_port, shared_component)
        
        final_key = fkey(received_shared_component, private_key)
        print(f"Computed final shared key: {final_key}")
        
        print(f"Party {name} completed the key exchange protocol.")
        
    except Exception as e:
        print(f"Error in Party {name}: {e}")
    finally:
        server_socket.close()

def send_message(host, port, message):
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client_socket.connect((host, port))
    client_socket.sendall(str(message).encode())
    print(f"Sent message: {message}")
    client_socket.close()
    return True

def receive_message(server_socket):
    conn, addr = server_socket.accept()
    data = conn.recv(4096).decode()
    message = int(data)
    conn.close()
    print(f"Received message: {message}")
    return message

party_c()
____________________________________________________________________________
//sha-512
def sha512(message):
    h0 = 0x6a09e667f3bcc908
    h1 = 0xbb67ae8584caa73b
    h2 = 0x3c6ef372fe94f82b
    h3 = 0xa54ff53a5f1d36f1
    h4 = 0x510e527fade682d1
    h5 = 0x9b05688c2b3e6c1f
    h6 = 0x1f83d9abfb41bd6b
    h7 = 0x5be0cd19137e2179
    
    k = [
        0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,
        0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,
        0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,
        0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,
        0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,
        0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,
        0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,
        0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,
        0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,
        0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,
        0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,
        0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,
        0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,
        0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,
        0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,
        0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,
        0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,
        0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,
        0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,
        0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817
    ]
    
    if isinstance(message, str):
        message = message.encode('utf-8')
    
    original_bit_length = len(message) * 8
    
    message = bytearray(message) + b'\x80'
    
    while (len(message) * 8) % 1024 != 896:
        message = message + b'\x00'
    
    message += original_bit_length.to_bytes(16, byteorder='big')
    
    for i in range(0, len(message), 128):
        chunk = message[i:i+128]
        
        w = [0] * 80
        for j in range(16):
            w[j] = int.from_bytes(chunk[j*8:j*8+8], byteorder='big')
        
        for j in range(16, 80):
            s0 = rotr(w[j-15], 1) ^ rotr(w[j-15], 8) ^ (w[j-15] >> 7)
            s1 = rotr(w[j-2], 19) ^ rotr(w[j-2], 61) ^ (w[j-2] >> 6)
            w[j] = (w[j-16] + s0 + w[j-7] + s1) & 0xffffffffffffffff
        
        a, b, c, d, e, f, g, h = h0, h1, h2, h3, h4, h5, h6, h7
        
        for j in range(80):
            sum1 = rotr(e, 14) ^ rotr(e, 18) ^ rotr(e, 41)
            ch = (e & f) ^ ((~e) & g)
            temp1 = (h + sum1 + ch + k[j] + w[j]) & 0xffffffffffffffff
            sum0 = rotr(a, 28) ^ rotr(a, 34) ^ rotr(a, 39)
            maj = (a & b) ^ (a & c) ^ (b & c)
            temp2 = (sum0 + maj) & 0xffffffffffffffff
            
            h = g
            g = f
            f = e
            e = (d + temp1) & 0xffffffffffffffff
            d = c
            c = b
            b = a
            a = (temp1 + temp2) & 0xffffffffffffffff
        
        h0 = (h0 + a) & 0xffffffffffffffff
        h1 = (h1 + b) & 0xffffffffffffffff
        h2 = (h2 + c) & 0xffffffffffffffff
        h3 = (h3 + d) & 0xffffffffffffffff
        h4 = (h4 + e) & 0xffffffffffffffff
        h5 = (h5 + f) & 0xffffffffffffffff
        h6 = (h6 + g) & 0xffffffffffffffff
        h7 = (h7 + h) & 0xffffffffffffffff
    
    digest = ''
    for val in [h0, h1, h2, h3, h4, h5, h6, h7]:
        digest += format(val, '016x')
    
    return digest

def rotr(x, n):
    return ((x >> n) | (x << (64 - n))) & 0xffffffffffffffff

m = input("Enter:")
print(f"SHA-512 of '{m}': {sha512(m)}")

____________________________________________________________________________
//dss
import random

P = 23
Q = 11
G = 2

def generate_keys():
    print("\n=== KEY GENERATION ===")
    
    x = random.randint(1, Q-1)
    print(f"Private key (x): {x}")
    
    y = pow(G, x, P)
    print(f"Public key (y): {y}")
    
    return x, y

def sign_message(x, message):
    print("\n=== SIGNING PROCESS ===")
    print(f"Message (M): {message}")
    
    h_m = message % Q
    print(f"H(M): {h_m}")
    
    k = random.randint(1, Q-1)
    print(f"Per-message secret (k): {k}")
    
    r = pow(G, k, P) % Q
    print(f"r = (g^k mod p) mod q = ({G}^{k} mod {P}) mod {Q} = {r}")
    
    k_inv = pow(k, -1, Q)
    print(f"k^(-1) mod q = {k_inv}")
    
    x_r = (x * r) % Q
    print(f"x*r mod q = {x} * {r} mod {Q} = {x_r}")
    
    h_m_plus_xr = (h_m + x_r) % Q
    print(f"(H(M) + x*r) mod q = ({h_m} + {x_r}) mod {Q} = {h_m_plus_xr}")
    
    s = (k_inv * h_m_plus_xr) % Q
    print(f"s = [k^(-1) * (H(M) + x*r)] mod q = {k_inv} * {h_m_plus_xr} mod {Q} = {s}")
    
    print(f"Signature (r, s): ({r}, {s})")
    return r, s

def verify_signature(y, message, signature):
    print("\n=== VERIFICATION PROCESS ===")
    print(f"Message (M): {message}")
    print(f"Signature (r, s): {signature}")
    
    r, s = signature
    
    h_m = message % Q
    print(f"H(M): {h_m}")
    
    w = pow(s, -1, Q)
    print(f"w = s^(-1) mod q = {s}^(-1) mod {Q} = {w}")
    
    u1 = (h_m * w) % Q
    print(f"u1 = [H(M)*w] mod q = ({h_m} * {w}) mod {Q} = {u1}")
    
    u2 = (r * w) % Q
    print(f"u2 = (r*w) mod q = ({r} * {w}) mod {Q} = {u2}")
    
    g_u1 = pow(G, u1, P)
    print(f"g^u1 mod p = {G}^{u1} mod {P} = {g_u1}")
    
    y_u2 = pow(y, u2, P)
    print(f"y^u2 mod p = {y}^{u2} mod {P} = {y_u2}")
    
    g_u1_times_y_u2 = (g_u1 * y_u2) % P
    print(f"(g^u1 * y^u2) mod p = ({g_u1} * {y_u2}) mod {P} = {g_u1_times_y_u2}")
    
    v = g_u1_times_y_u2 % Q
    print(f"v = [(g^u1 * y^u2) mod p] mod q = {g_u1_times_y_u2} mod {Q} = {v}")
    
    print(f"TEST: v = {v}, r = {r}")
    result = v == r
    print(f"Signature valid: {result}")
    
    return result

def main():
    private_key, public_key = generate_keys()
    
    message = 42
    signature = sign_message(private_key, message)
    
    verify_signature(public_key, message, signature)

if __name__ == "__main__":
    main()

____________________________________________________________________________
//hmac
import hashlib

key = input("Enter Key: ")

IPAD_VALUE = "00110110"
OPAD_VALUE = "01011100"

blocks = len(key) // 8
if len(key) % 8 != 0:
    blocks += 1

ipad = IPAD_VALUE * blocks if len(key) > 8 else IPAD_VALUE
opad = OPAD_VALUE * blocks if len(key) > 8 else OPAD_VALUE

key_int = int(key, 2)
ipad_int = int(ipad, 2)
opad_int = int(opad, 2)

print("K:", key_int)

message = input("Enter message: ")
message_bytes = message.encode('ascii')

inner_key = str(key_int ^ ipad_int).encode('ascii')
inner_message = inner_key + message_bytes
print("Message 1:\n", inner_message)

inner_hash = hashlib.sha512(inner_message)
inner_hash_result = inner_hash.hexdigest().encode()
print("H((K' ^ ipad)||m):\n", inner_hash_result)

outer_key = str(key_int ^ opad_int).encode('ascii')
outer_message = outer_key + inner_hash_result
print("Message 2:\n", outer_message)

final_hash = hashlib.sha512(outer_message)
final_hash_result = final_hash.hexdigest().encode()
print("H((K' ^ opad)|| H((K' ^ ipad)||m))):\n", final_hash_result)
print("\n")
    
__________________________________________________________________________
//dss
//Signing ( signing.py )
import socket
def modinv(x,y):
    i=1
    while(True):
        if((x*i)%y==1):
            return i
        i+=1


clientSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
addr=('127.0.0.1', 12400)
p=int(input('Enter p: '))
q=int(input('Enter q: '))
h=int(input('Enter h: '))
g=(h**((p-1)//q))%p
print('g:',g)
x=int(input('Enter x: '))
y=(g**x)%p
print('y:',y)
Hm=int(input('Enter H(m): '))
k=int(input('Enter k: '))
#signing 
r=((g**k)%p)%q
inv=modinv(k,q)
s=inv*(Hm+x*r)%q
print("Signature (r,s):",r,s)
send=str(r)+" "+str(s)+" "+str(Hm)+" "+str(g)+" "+str(y)
clientSocket.sendto(send.encode(), addr)

//Verifying ( verify.py )
import socket

def modinv(x,y):
    i=1
    while(True):
        if((x*i)%y==1):
            return i
        i+=1



serverSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
serverSocket.bind(('', 12400))
p=int(input('Enter p: '))
q=int(input('Enter q: '))
signature, addr = serverSocket.recvfrom(1024)
signature=signature.decode()
r,s,Hm,g,y=map(int,signature.split())
print("Received r,s,Hm,g,y: ",r,s,Hm,g,y)
#verifying
w=modinv(s,q)
v1=(Hm*w)%q
v2=(r*w)%q
print("V1:",v1)
print("V2:",v2)
v=(((g**v1)*(y**v2))%p)%q
print("V:",v)
if(v==r):
    print("Verified")
else:
    print("Not Verified")
____________________________________________________________________________ //diffie-hellman


User A
( user1.py )


import socket
q=17
Xa=6
a=3

#Ya to B
clientSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
addr=('127.0.0.1', 12000)
Ya=a**Xa % q 
st=str(Ya)
clientSocket.sendto(st.encode(), addr)
print("Ya",Ya)

#recv Ybc from C
serverSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
serverSocket.bind(('', 12003))
cipher, addr = serverSocket.recvfrom(1024)
Ybc=int(cipher.decode())
print("Recieved Ybc from C",Ybc)
K=(Ybc)**Xa % q 
print("K",K)

#recv Yc from C
cipher, addr = serverSocket.recvfrom(1024)
Yc=int(cipher.decode())
Yca=(Yc)**Xa % q 
print("Recieved Yc from C",Yc)
print("Yca",Yca)

#send Yca to B
st=str(Yca)
addr=('127.0.0.1', 12000)
clientSocket.sendto(st.encode(), addr)







User B
( user2.py )

import socket
q=17
Xb=3
a=3

#Recieve Ya from A
serverSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
serverSocket.bind(('', 12000))
cipher, addr = serverSocket.recvfrom(1024)
Ya=int(cipher.decode())
print("Ya Received from A",Ya)
Yab=Ya**Xb % q 
print("Yab",Yab)

#Send Yab to C
clientSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
addr=('127.0.0.1', 12001)
st=str(Yab)
clientSocket.sendto(st.encode(), addr)


#Calculate Yb and Send to C
Yb=a**Xb % q
st=str(Yb)
print("Yb",Yb)
clientSocket.sendto(st.encode(), addr)

#Recv Yca form A
cipher, addr = serverSocket.recvfrom(1024)
Yca=int(cipher.decode())
print("Yca Received from A",Yca)
K=Yca**Xb % q 
print("K",K)






User C
( user3.py )

import socket
Xc=4 
a=3
q=17

#Recv from Yab from B
serverSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
serverSocket.bind(('', 12001))
cipher, addr = serverSocket.recvfrom(1024)
Yab=int(cipher.decode())
print("Received Yab from B",Yab)
K=(Yab)**Xc % q 
print("K",K)

#recv Yb from B
cipher, addr = serverSocket.recvfrom(1024)
Yb=int(cipher.decode())
print("Received Yb from B",Yb)
Ybc=(Yb)**Xc % q
print("Ybc",Ybc)

#Send Ybc to A 
clientSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
addr=('127.0.0.1', 12003)
st=str(Ybc)
clientSocket.sendto(st.encode(), addr)


#Send Yc to A
Yc=a**Xc%q
print("Yc",Yc)
st=str(Yc)
clientSocket.sendto(st.encode(), addr)
____________________________________________________________________________
//s-des
server.py ( Server ): 
import socket
def calinitalperm(ct):
    ip=[2,6,3,1,4,8,5,7]
    ctip=""
    for i in range(0,len(ip)):
        ctip+=ct[ip[i]-1]
    return ctip

def complexfuncdec(ctip,sk1,sk2):
    #complex function with sk1
    #exponential permutation
    ep=[4,1,2,3,2,3,4,1]
    s0box=[[1,0,3,2],[3,2,1,0],[0,2,1,3],[3,1,3,2]]
    s1box=[[0,1,2,3],[2,0,1,3],[3,0,1,0],[2,1,0,3]]
    p4=[2,4,3,1]
    ip=[4,1,3,5,7,2,8,6]
    l=ctip[:4]
    r=ctip[4:]
    expperm=""
    for i in range(0,len(ep)):
        expperm+=r[ep[i]-1]
    print("Exponential Permutation: ",expperm)
    #xor
    xor=""
    for i in range(len(expperm)):
        if(expperm[i]==sk2[i]):
            xor+="0"
        else:
            xor+="1"
    print("XOR: ",xor)
    #substitution
    s0r=xor[0]+xor[3]
    s0c=xor[1:3]
    s1r=xor[4]+xor[7]
    s1c=xor[5:7]
    print("Rows and Columns: ")
    print(s0r,s0c,s1r,s1c)
    s0=s0box[int(s0r,2)][int(s0c,2)]
    s1=s1box[int(s1r,2)][int(s1c,2)]
    print(s0,s1)
    s0s1=""
    if(len(bin(s0)[2:])!=2):
        s0s1+="0"
    s0s1+=bin(s0)[2:]
    if(len(bin(s1)[2:])!=2):
        s0s1+="0"
    s0s1+=bin(s1)[2:]
    print("Concat: ",s0s1)
    #permutation p4
    p4st=""
    for i in range(len(p4)):
        p4st+=s0s1[p4[i]-1]
    print("P4: ",p4st)
    #final
    final1=""
    for i in range(len(p4)):
        if(p4st[i]==l[i]):
            final1+="0"
        else:
            final1+="1"
    final1+=r 
    print("L^F(R,SK2)R: ",final1)
    #swap
    swapped=final1[4:]+final1[:4]
    print("Swap: ",swapped)
    #complex function with sk2
    #exponential permutation
    l=swapped[:4]
    r=swapped[4:]
    expperm=""
    for i in range(0,len(ep)):
        expperm+=r[ep[i]-1]
    print("Exponential Permutation:",expperm)
    #xor
    xor=""
    for i in range(len(expperm)):
        if(expperm[i]==sk1[i]):
            xor+="0"
        else:
            xor+="1"
    print("XOR: ",xor)
    #substitution
    s0r=xor[0]+xor[3]
    s0c=xor[1:3]
    s1r=xor[4]+xor[7]
    s1c=xor[5:7]
    print("Rows and Columns: ")
    print(s0r,s0c,s1r,s1c)
    s0=s0box[int(s0r,2)][int(s0c,2)]
    s1=s1box[int(s1r,2)][int(s1c,2)]
    print(s0,s1)
    s0s1=""
    if(len(bin(s0)[2:])!=2):
        s0s1+="0"
    s0s1+=bin(s0)[2:]
    if(len(bin(s1)[2:])!=2):
        s0s1+="0"
    s0s1+=bin(s1)[2:]
    print("Concat: ",s0s1)
    #permutation p4
    p4st=""
    for i in range(len(p4)):
        p4st+=s0s1[p4[i]-1]
    print("P4: ",p4st)
    #final
    temp=""
    for i in range(len(p4)):
        if(p4st[i]==l[i]):
            temp+="0"
        else:
            temp+="1"
    temp+=r 
    print("L^F(R,SK1)R: ",temp)
    #apply inverseperm
    ciphertext=""
    for i in range(len(ip)):
        ciphertext+=temp[ip[i]-1]
    return ciphertext
while True:
    serverSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    serverSocket.bind(('', 12000))
    sk1=input("Enter SK1: ")
    sk2=input("Enter SK2: ")
    ct, addr = serverSocket.recvfrom(1024)
    ct=ct.decode()
    ctip=calinitalperm(ct)
    print("Inital Permutation: ",ctip)
    decrypted=complexfuncdec(ctip,sk1,sk2)
    print("Decrypted Text:",decrypted)
    if decrypted=="00000000":
        break
____________________________________________________________________________

